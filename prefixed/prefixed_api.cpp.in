// alloc8 - Prefixed allocation API implementation
// Generated source for prefix: @ALLOC8_PREFIX@
//
// This file was generated by CMake. Do not edit manually.
//
// USAGE: Your allocator library must also compile a file that:
//   1. Includes <alloc8/alloc8.h>
//   2. Defines your allocator class
//   3. Uses ALLOC8_REDIRECT(YourHeapRedirect) to generate xxmalloc/xxfree

#include "@ALLOC8_PREFIX@_malloc.h"
#include <alloc8/alloc8.h>

#include <cstring>
#include <cerrno>
#include <climits>

// Forward declarations - provided by ALLOC8_REDIRECT macro
extern "C" {
  void* xxmalloc(size_t);
  void  xxfree(void*);
  void* xxmemalign(size_t, size_t);
  size_t xxmalloc_usable_size(void*);
  void xxmalloc_lock();
  void xxmalloc_unlock();
  void* xxrealloc(void*, size_t);
  void* xxcalloc(size_t, size_t);
}

// ─── CORE ALLOCATION FUNCTIONS ────────────────────────────────────────────────

extern "C" {

void* @ALLOC8_PREFIX@_malloc(size_t size) {
  return xxmalloc(size);
}

void @ALLOC8_PREFIX@_free(void* ptr) {
  if (ptr) {
    xxfree(ptr);
  }
}

void* @ALLOC8_PREFIX@_realloc(void* ptr, size_t size) {
  return xxrealloc(ptr, size);
}

void* @ALLOC8_PREFIX@_calloc(size_t count, size_t size) {
  return xxcalloc(count, size);
}

// ─── ALIGNED ALLOCATION ───────────────────────────────────────────────────────

void* @ALLOC8_PREFIX@_memalign(size_t alignment, size_t size) {
  return xxmemalign(alignment, size);
}

int @ALLOC8_PREFIX@_posix_memalign(void** memptr, size_t alignment, size_t size) {
  *memptr = nullptr;

  // Alignment must be power of 2 and multiple of sizeof(void*)
  if (alignment < sizeof(void*) ||
      (alignment & (alignment - 1)) != 0) {
    return EINVAL;
  }

  void* ptr = xxmemalign(alignment, size);
  if (!ptr && size != 0) {
    return ENOMEM;
  }

  *memptr = ptr;
  return 0;
}

void* @ALLOC8_PREFIX@_aligned_alloc(size_t alignment, size_t size) {
  // C11: size must be multiple of alignment
  if (alignment == 0 || (size % alignment) != 0) {
    return nullptr;
  }
  return xxmemalign(alignment, size);
}

void* @ALLOC8_PREFIX@_valloc(size_t size) {
  return xxmemalign(ALLOC8_PAGE_SIZE, size);
}

void* @ALLOC8_PREFIX@_pvalloc(size_t size) {
  size_t pageSize = ALLOC8_PAGE_SIZE;
  size_t rounded = (size + pageSize - 1) & ~(pageSize - 1);
  return xxmemalign(pageSize, rounded);
}

// ─── SIZE QUERY ───────────────────────────────────────────────────────────────

size_t @ALLOC8_PREFIX@_malloc_usable_size(void* ptr) {
  return xxmalloc_usable_size(ptr);
}

// ─── STRING FUNCTIONS ─────────────────────────────────────────────────────────

char* @ALLOC8_PREFIX@_strdup(const char* s) {
  if (!s) return nullptr;
  size_t len = strlen(s) + 1;
  char* newStr = (char*)xxmalloc(len);
  if (newStr) {
    memcpy(newStr, s, len);
  }
  return newStr;
}

char* @ALLOC8_PREFIX@_strndup(const char* s, size_t n) {
  if (!s) return nullptr;

  // Find actual length (up to n)
  size_t len = 0;
  while (len < n && s[len]) {
    ++len;
  }

  char* newStr = (char*)xxmalloc(len + 1);
  if (newStr) {
    memcpy(newStr, s, len);
    newStr[len] = '\0';
  }
  return newStr;
}

// ─── LOCK/UNLOCK ──────────────────────────────────────────────────────────────

void @ALLOC8_PREFIX@_malloc_lock(void) {
  xxmalloc_lock();
}

void @ALLOC8_PREFIX@_malloc_unlock(void) {
  xxmalloc_unlock();
}

// ─── EXTENSIONS ───────────────────────────────────────────────────────────────

void* @ALLOC8_PREFIX@_reallocarray(void* ptr, size_t nmemb, size_t size) {
  // Overflow check
  if (size != 0 && nmemb > SIZE_MAX / size) {
    errno = ENOMEM;
    return nullptr;
  }
  return xxrealloc(ptr, nmemb * size);
}

} // extern "C"
